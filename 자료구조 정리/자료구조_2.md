# 자료구조 DAY2

<br>

## ⏱ 시간 복잡도 & 빅오 표기법

### 1. 알고리즘의 시간 복잡도 = 시간이 얼마나 걸리는가

#### ❓ 좋은 알고리즘 이란?

> Input을 넣은 후 Output이 나오는 시간이 짧은 알고리즘

<br>

#### 알고리즘의 소요 시간 측정하기 

- **개개인의 컴퓨터 환경**에 따라 같은 알고리즘이라도 **측정 시간이 다르다**
  - 환경에 영향을 받지 않는 **객관적 기준의 필요성**
- 객관적인 기준을 위해 알고리즘 내부에서 **기본 연산이 몇번 일어나는지** 측정
  - 기본연산 : 단위 시간 1이 소요되는 연산
- **`기본연산의 총 횟수 == 알고리즘의 소요시간`**
  - **입력의 개수에 따라 시간이 달라진다**는 문제가 존재
  - 따라서 **입력을 통일**시킨다. 즉, 가장 기본연산이 많이 일어나는 **최악의 입력 n개**가 들어온다고 가정
    - 이를 수식으로 나타낸 것이 *시간 복잡도*

<br>

#### ⏱ 시간 복잡도

>  단순하게 알고리즘의 수행 시간을 의미

- 시간 복잡도가 높다 > 느린 알고리즘
- 시간 복잡도가 낮다 > 빠른 알고리즘

<br>

### 2. 빅오(Big-O) 표기법

#### ❓빅오 표기법이란?

> 입력 n이 **무한대로 커진다고 가정**하고 시간 복잡도를 간단하게 표시
>
> **최고차항**만 남기고 계수와 상수 제거

- 정확한 수치보다는 증가율에 초점
- 3n + 2 , 6n + 4 는 계수와 상수 제거하고 최고차항은 n이다 => 동일한 시간 복잡도라 판단
- 다만, 4n^2 + 5와 비교하게 된다면 최고차항 n과 n^2 이므로 n^2이 시간 복잡도가 높다

<br>

> 시간 복잡도 순서 정렬 (**낮음 ▶️ 높음**)

![다운로드](https://user-images.githubusercontent.com/108653518/180987912-264d82af-3580-41f2-bdd6-f334229c7c6f.png)

- **`O(1)`** 
  - 단순 산술 계산(덧셈, 뺄셈, 곱셈, 나눗셈)
- **`O(logN)`**
  - 크기 N인 리스트를 반절씩 순회/탐색
  - *이진탐색, 분할정복*
- **`O(N)`**
  - 크기 N인 리스트를 순회
  - *1중 for문*
- **`O(NlogN)`**
  - 크기 N인 리스트를 반절씩 순회/탐색
  - *sort가 해당 - 높은 성능의 정렬*
- **`O(N^2)`**
  - 크기 M, N인 2중 리스트를 순회
  - *2중 for문*
- `O(N^3)`
  - 3중 리스트를 순회
  - *3중 for문*
- `O(2^N)`
  - 크기 N 집합의 부분 집합
- `O(N!)`
  - 크기가 N인 순열

<br>

## `Python`의 리스트(List ; [])

### 1. 배열과 연결리스트의 장점을 모두 가지고 있다

#### 배열(Array)

> 여러 데이터들이 연속된 메모리 공간에 저장되어 있는 자료구조

- **인덱스를 통해 데이터에 빠르게 접근** - 조회가 쉬움
  - 데이터마다 메모리 주소가 할당되어 있기 때문
- 배열의 길이는 변경 불가능 ▶️ 길이를 변경하고 싶다면 새로 생성 
  - 보완하기 위해 : 연결 리스트
- 데이터 타입은 고정

<br>

#### 연결 리스트(Linked List)

> 데이터가 담긴 여러 노드들이 순차적으로 연결된 형태의 자료구조

- 맨 처음 노드부터 순차적으로 탐색
- **연결리스트의 길이 자유롭게 변경 가능** ▶️ 삽입, 삭제가 편리
- 다양한 데이터 타입 저장
- 데이터가 메모리에 연속적으로 저장되지 않음

<br>

### 2. 파이썬 리스트의 메서드

- **`.append(원소)`**
  - 리스트 맨 끝에 새로운 원소 **삽입**
  - 이미 각각 주소가 저장이 되어 있기에 오른쪽 끝에 넣는 것은 쉽다
  - 즉, O(1)

<br>

- **`.pop(인덱스)`**
  - 특정 인덱스에 있는 원소를 **삭제 및 반환**
  - b = a.pop() 처럼 반환값(return)이 있다.
  - 역시나 주소는 저장 되어 있기에 그 주소값에 해당하는 인덱스를 지우면 됨 ▶️ O(1)

<br>

- **`.count(원소)`**
  - 리스트에서 해당 원소의 **개수**를 반환
  - O(N)

<br>

- **`.index(원소)`**
  - 리스트에서 처음으로 원소가 등장하는 **인덱스** 반환
  - O(N)

<br>

- **`.sort()`**
  - 리스트를 오름차순으로 **정렬**
  - **reverse=True** 옵션을 통해 내림차순으로 정렬 가능
  - O(NlogN)

<br>

- **`.reverse()`**
  - 리스트의 원소들의 순서를 거꾸로 **뒤집기**
  - O(N)

<br>

### 3. 리스트 관련 내장함수

- **`len(iterable)`**
  - 리스트의 **길이**(원소의 개수)를 반환 
  - O(1)

<br>

- **`sum(iterable)`**
  - 리스트의 모든 원소의 **합**을 반환
  - O(n)

<br>

- **`max(iterable)`**
  - 리스트의 원소 중 **최대값**을 반환
  - O(n)

<br>

- **`min(iterable)`**
  - 리스트의 원소 중 **최소값**을 반환
  - O(n)

<br>

- **`sorted(iterable)`**
  - 오름차순으로 **정렬**된 새로운 리스트 반환
  - 원본 리스트는 변화 없음
  - O(NlogN)

<br>

- **`reversed(iterable)`**
  - 리스트의 순서를 거꾸로 **뒤집은** 새로운 객체 반환
  - 원본 리스트는 변화 없음



<br>

<br>

<br>

<br>

### 참고 / 도움되는 자료

- <https://yoongrammer.tistory.com/79> - 빅오 표기법(사진/설명)

- <https://wiki.python.org/moin/TimeComplexity> - 시간 복잡도