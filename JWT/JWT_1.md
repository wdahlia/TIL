# JWT를 사용한 로그인 구현
> 쿠키, 세션, 토큰이란?
<br>

- **인증**(Authentication) - 사용자가 자기 계정을 사용하려고 할 때, 로그인 시키는 것
- **인가**(Authorization) - 인증 받은 사용자가 서비스 안에서 돌아다닐 때, 서버에서 이 사용자가 인증받은 사용자임을 확인하고 허가해주는 것
- JWT의 경우 **인가**(Authorization)에 관한 기술
- 서버가 클라이언트 인증을 확인하는 방식
	- 쿠키, 세션, 토큰

<br>

### 쿠키
- `key - value` 형식의 문자열 덩어리
- 웹사이트를 방문할 경우, 그 사이트가 사용하고 있는 서버를 통해 클라이언트의 브라우저에 설치되는 작은 기록 정보 파일
- 각 사용자마다 브라우저에 정보를 저장하기에 고유 정보 식별 가능함

<br>

#### `쿠키 인증 방식`
- **클라이언트에서 서버에 요청**을 보냄
- **서버는 클라이언트의 요청에 응답 작성** 시, 클라이언트 측에 저장하고 싶은 정보를 **응답 헤더의 Set-Cookie에 담는다**
- 이후, **해당 클라이언트가 요청을 보낼 때마다, 매번 저장된 쿠키를 요청 헤더의 Cookie에 담아 보낸다**. 서버는 쿠키에 담긴 정보를 바탕으로 해당 요청의 클라이언트가 누군지 식별하거나 정보를 바탕으로 추천 광고를 띄우거나 함
  
<br>

#### 쿠키 단점
- 보안에 취약, 요청 시 쿠키의 값을 그대로 보내기 때문에 유출 및 조작당할 위험 존재
- 용량 제한이 있어 많은 정보 담지 못함
- 웹 브라우저마다 쿠키에 대한 지원 형태가 다르기 때문에 브라우저간 공유가 불가능
- 쿠키의 사이즈가 커질수록 네트워크에 부하가 심해짐
- 웹 브라우저마다 쿠키에 대한 지원 형태 다르기에 브라우저간 공유 불가능
- 쿠키 사이즈 커질수록 네트워크에 부하 심해짐

<br>

### 세션
- `Stateful`
- 쿠키의 보안적인 이슈로 인해, 클라이언트의 민감한 인증 정보를 브라우저가 아닌 서버 측에 저장하고 관리
- 서버에 저장하는 방법
	- 메모리에 저장(속도 빠름, 대신 휘발성이 있기 때문에 에러가 발생하면 모든 정보가 날라갈 수 있음)
	- 하드 디스크
	- 데이터 베이스 저장(보통 DB를 분산해서 관리하기 때문에, 시간이 오래 소요될 수 있다라는 단점 존재)
- 세션 객체는 Key에 해당하는 SESSION ID와 이에 대응하는 Value로 구성
	- Value에는 세션 생성 시간, 마지막 접근 시간, User가 저장한 속성 등이 Map 형태로 저장
	- `userId` 
		- type : String
		- 세션의 고유 아이디
	- `creationTime`
		- type : long
		- 세션이 생성된 시간을 구함 단위는 1/1000초
	- `lastAccessedTime`
		- type : long
		- 웹 브라우저가 가장 마지막에 세션에 접근한 시간 1/1000초
	- `setAttribute()` , `getAttribute()`등의 메서드를 사용, 속성값을 저장하거나 읽어 올 수 있음

<br>

#### `세션 인증 방식`
- 유저가 웹사이트에 **로그인하면 세션이 서버 메모리(or DB)에 저장**
	- **세션을 식별하기 위한 Session Id를 기준으로 정보 저장**
- 서버에서 **브라우저 쿠키에다가 Session Id**를 저장
- 쿠키에 정보가 담겨있기 때문에 브라우저는 **모든 요청에 Session Id를 쿠키에 담아 전송**
- **서버**는 클라이언트 측에서 보낸 Session Id와 서버 메모리(or DB)로 관리하고 있는 **Session Id를 비교하여 인증 수행**

<br>

#### 세션 단점
- 쿠키를 포함한 요청이 외부에 노출 되더라고 유의미한 개인정보를 담지 않고 있기 때문에 상관 없으나 만약 세션 ID 자체를 탈취하여 클라이언트 인척 위장할 수 있다는 한계 존재
	- 하지만 서버에서 IP특정을 통해 다른 기기로의 접근이 발생하는 경우 세션을 만료 하는 방식으로 해결 가능
- 서버에서 세션 저장소를 사용하므로 요청이 많아진다면 서버에 부하가 심해짐

<br>

### 토큰
- `Stateless`
- 세션기반 인증은 서버가 파일이나 데이터베이스에 세션 정보를 가지고 있어야하므로 조회하는 과정에서 부하가 발생할 수 있음
- 하지만, 토큰의 경우 클라이언트에 저장되기 때문에 서버의 부담을 덜 수 있음
- 앱과 서버가 통신 및 인증할때 가장 많이 사용 웹에는 쿠키와 세션이 존재하나 앱에는 존재하지 않기 때문
<br>

#### `토큰 인증 방식`
- 사용자가 아이디와 비밀번호로 로그인
- 서버 측에서 클라이언트에게 유일한 토큰을 발급
- 클라이언트는 서버 측에서 전달받은 토큰을 쿠키나 스토리지에 저장해두고, 서버에 요청을 할 때마다 해당 토큰을 HTTP요청 헤더에 포함시켜 서버에 전달
- 서버는 전달받은 토큰을 검증하고 요청에 응답, 토큰에는 요청한 사람의 정보가 담겨있기에 서버는 DB를 조회하지 않고 누가 요청하는 징 알 수 있다
	- 즉 header와 payload 서버에 감춰놓은 비밀 값 세개를 header에 포함된 암호화 알고리즘을 사용해서 돌려서 그 값이 일치하는지를 판단하는 것

<br>

#### 토큰 단점
- 토큰 자체의 데이터 길이가 길기 때문에, 인증 요청이 많아질수록 네트워크 부하가 심해질 가능성
- Payload 자체는 암호화되지 않기 때문에 유저의 중요한 정보는 담을 수 없음
- 토큰을 탈취당하면 대처하기 어렵다
	- 사용 기간 제한을 설정하는 식으로 극복
		- 세션의 경우에는 세션을 만료하는 식으로 대응할 수 있으나 토큰의 경우는 서버가 기록을 해서 추적하는 방식이 아니니 대응이 불가능
		- 사용 기간 제한을 설정하는 식으로 극복
			- access 토큰과 refresh 토큰을 사용하는 방식
			- refresh 토큰은 상응값을 데이터베이스에도 저장

<br>

[참고자료 - 블로그](https://inpa.tistory.com/entry/WEB-%F0%9F%93%9A-JWTjson-web-token-%EB%9E%80-%F0%9F%92%AF-%EC%A0%95%EB%A6%AC)

[참고자료 - 유투브](https://www.youtube.com/watch?v=1QiOXWEbqYQ&list=PLpO7kx5DnyIEXyPYwOk4YFFmtz5yz1v36&index=5&ab_channel=%EC%96%84%ED%8C%8D%ED%95%9C%EC%BD%94%EB%94%A9%EC%82%AC%EC%A0%84)
