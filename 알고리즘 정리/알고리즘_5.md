# 알고리즘 DAY5

<br>

## 깊이우선탐색(DFS)

### 1. 그래프 탐색 알고리즘

> 시작 정점에서 간선을 타고 이동할 수 있는 모든 정점을 찾는 알고리즘

![DFS vs BFS](https://user-images.githubusercontent.com/108653518/184154703-c3ebe5c2-7cb7-4855-ac0c-b60503e503ea.jpg)

- `깊이우선탐색(DFS) `
  -  그래프의 깊이를 우선으로 탐색하기 위해 **스택**의 개념 활용
- `너비우선탐색(BFS)`
  - 그래프의 너비를 우선으로 탐색하기 위해 **큐**의 개념 활용

 <br>

### 2. 깊이우선탐색(DFS)

> 시작 정점으로부터 **갈 수 있는 하위 정점까지 가장 깊게 탐색**하고
>
> 제일 끝 하위 정점이라면 **마지막 갈림길(이전 노드)로 돌아와서 다른 정점을 탐색**하며 결국 모든 정점을 방문

- 미로 탈출로 생각한다면 쉽게 이해 가능
  - 한 쪽 길로 깊게 들어갔다가 막히면 다시 돌아와서 다른 길을 탐색

<br>

#### 💡 DFS의 특징

- 모든 정점을 방문 시 유리
- `경우의 수`, `순열과 조합` 문제에 많이 사용
- BFS에 비해 코드 구현이 간단
- 모든 정점을 방문할 필요가 없거나 최단거리를 구할 때에는 BFS가 유리

<br>

### 3. DFS의 동작 과정

![DFS 동작과정](https://user-images.githubusercontent.com/108653518/184154695-f7a84fcc-f1d3-48d7-9fed-600c2bf3a1b7.jpg)

#### 1️⃣ **탐색을 진행할 그래프가 필요**

- 그래프는 `인접 행렬` OR  `인접 리스트 방식`으로 표현
- 이미 탐색한 노드는 고려할 대상에서 제외시켜야 한다는 것을 인식할 것

<br>

#### 2️⃣ 각 정점을 방문했는지 여부를 판별

- True, False가 아니고 1,0으로 해도 무방, 빈 리스트에 정점을 넣어줘도 됨

```python
visted = [False] * N # N은 정점의 개수
```

|     정점 i     |  `0`  |  `1`  |  `2`  |  `3`  |  `4`  |  `5`  |  `6`  |
| :------------: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| visited[**i**] | False | False | False | False | False | False | False |

<br>

#### 3️⃣ DFS의 사이클

- `현재 정점 방문처리`

  - |     정점 i     |   `0`    |  `1`  |  `2`  |  `3`  |  `4`  |  `5`  |
    | :------------: | :------: | :---: | :---: | :---: | :---: | :---: |
    | visited[**i**] | **True** | False | False | False | False | False |

    예를 들어, **visited[**`0`**]**을 방문한다면 **visited[**`0`**]** = **True**

  - 이 과정을 끝날 때까지 반복

- `인접한 모든 정점 확인`
- `방문하지 않은 인접 정점 이동`
  - 이 때, 방문하지 않은 인접 정점을 이동하기 위해서는
  - 직전에 방문 했던 정점으로 돌아가야 함을 코드 짤 때 유의할 것

<br>

### 4. DFS의 구현 방식

> 인접 리스트로 표현한 그래프를 기준으로 구성

```python

# 코드
visited = [False] * N # 방문 처리 리스트 만들기

def dfs(start):
  visited[start] = True # 시장 정점 방문 처리
  stack = [start] # 돌아갈 곳을 기록

  while len(stack) != 0: # 스택이 빌 때까지(돌아갈 곳이 없을때까지) 반복
    current = stack.pop() # 현재 방문 정점(후입선출)

    for adj in graph[current]:
      if not visited[adj]:
        visited[adj] = True
        stack.append(adj)
dfs(1)
        
```

<br>

- `관련 문제`

  - [BOJ 2644 - 촌수계산](https://www.acmicpc.net/problem/2644)

    ![촌수계산 로직](https://user-images.githubusercontent.com/108653518/184154689-a0e25df2-2d1f-49bf-850e-b077c8735e0d.jpg)

  - [BOJ 2606 - 바이러스](https://www.acmicpc.net/problem/2606)

<br>

### 👩🏻‍💻 코딩 테스트 준비

> 기본 코딩 테스트는 주로 문제의 내용을 코드로 구현 가능한지 테스트

- 문제 풀이에 **시간 제한이 없는 경우 많음**, 시간 복잡도를 생각하지 않고 풀이하는 것이 좋다
- `완전 탐색`중에서도 `2차원 배열의 탐색`, `델타 탐색` 등 **선형 탐색**이 주를 이룬다

<br>

#### 🔗 단순 구현 (Implementation)

[BOJ 1063 - 킹](https://www.acmicpc.net/problem/1063)

> **문제에 제시된 풀이 과정을 그대로 구현**하는 유형

- 시뮬레이션의 경우 완전탐색 유형 중 하나로써, 모든 경우의 수를 탐색하여 풀이
- 아이디어, 알고리즘을 요구하기 보다는 제시된 과정을 그대로 구현할 수 있는가가 핵심

- DFS를 이용해 이차원 격자를 탐색하는 문제 자주 출제 (미로 문제)

<br>



